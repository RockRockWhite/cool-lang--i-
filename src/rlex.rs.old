use serde::{Deserialize, Serialize};
use std::collections::HashMap;

// declarations
// ======================
pub struct Token {
    // 词法单元
    pub token_type: String,
    pub token_value: String,
}
// ======================

#[derive(Serialize, Deserialize)]
pub struct LookupTable {
    pub accept_states: Vec<usize>,
    pub states: Vec<HashMap<u8, usize>>,
}

impl LookupTable {
    pub fn new() -> Self {
        LookupTable {
            accept_states: Vec::new(),
            states: Vec::new(),
        }
    }

    pub fn is_acceptable(&self, id: usize) -> bool {
        self.accept_states.contains(&id)
    }
}

pub struct Rlex {
    // variables
    // ======================
    pub res: Vec<Token>,
    // ======================
}

impl Rlex {
    pub fn lex(&self, s: &str) {
        // 词法分析
        // 生成lookup_table
        let lookup_table:Vec<LookupTable>= serde_json::from_str(r#"[{"accept_states":[0,1,2,3,4,5],"states":[{"50":3,"51":1,"52":2,"49":4,"48":5},{"50":3,"52":2,"51":1,"49":4,"48":5},{"50":3,"48":5,"49":4,"51":1,"52":2},{"52":2,"48":5,"49":4,"50":3,"51":1},{"51":1,"49":4,"52":2,"48":5,"50":3},{"48":5,"50":3,"51":1,"49":4,"52":2}]},{"accept_states":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],"states":[{"101":15,"99":13,"100":1,"97":12,"98":14},{"98":2,"51":11,"50":9,"48":3,"97":4,"100":6,"49":5,"52":10,"101":7,"99":8},{"99":8,"97":4,"51":11,"52":10,"48":3,"98":2,"49":5,"101":7,"50":9,"100":6},{"52":10,"100":6,"98":2,"50":9,"48":3,"49":5,"97":4,"51":11,"99":8,"101":7},{"49":5,"100":6,"97":4,"51":11,"50":9,"99":8,"98":2,"48":3,"101":7,"52":10},{"50":9,"48":3,"49":5,"52":10,"51":11,"97":4,"98":2,"99":8,"101":7,"100":6},{"100":6,"98":2,"101":7,"49":5,"51":11,"50":9,"99":8,"52":10,"97":4,"48":3},{"101":7,"52":10,"98":2,"51":11,"99":8,"50":9,"100":6,"49":5,"48":3,"97":4},{"51":11,"98":2,"101":7,"49":5,"52":10,"48":3,"100":6,"99":8,"97":4,"50":9},{"49":5,"48":3,"100":6,"50":9,"101":7,"52":10,"99":8,"51":11,"98":2,"97":4},{"49":5,"52":10,"50":9,"48":3,"97":4,"51":11,"99":8,"98":2,"100":6,"101":7},{"52":10,"51":11,"49":5,"97":4,"48":3,"101":7,"100":6,"99":8,"98":2,"50":9},{"99":8,"49":5,"48":3,"51":11,"100":6,"98":2,"97":4,"101":7,"50":9,"52":10},{"101":7,"49":5,"99":8,"97":4,"51":11,"98":2,"50":9,"52":10,"48":3,"100":6},{"51":11,"50":9,"100":6,"49":5,"97":4,"98":2,"101":7,"52":10,"48":3,"99":8},{"49":5,"101":7,"97":4,"48":3,"100":6,"51":11,"50":9,"98":2,"99":8,"52":10}]},{"accept_states":[0,1,2,3,4,5,6],"states":[{"44":3,"33":6,"59":1,"32":4,"61":5,"63":2},{"32":4,"63":2,"44":3,"59":1,"33":6,"61":5},{"44":3,"32":4,"59":1,"33":6,"61":5,"63":2},{"61":5,"63":2,"32":4,"33":6,"44":3,"59":1},{"33":6,"59":1,"61":5,"63":2,"44":3,"32":4},{"44":3,"63":2,"32":4,"61":5,"59":1,"33":6},{"61":5,"33":6,"44":3,"59":1,"63":2,"32":4}]}]"#).unwrap();
        let mut handler_funcs: Vec<Box<dyn Fn(&str) -> ()>> = Vec::new();

        // rules
        // ======================
        handler_funcs.push(Box::new(|s| println!("{} is a number", s)));
        handler_funcs.push(Box::new(|s| println!("{} is a identifier", s)));
        handler_funcs.push(Box::new(|s| println!("{} is a operator", s)));
        // ======================

        // 执行词法分析
        let mut match_str: &str = "";
        let mut res_str = s;

        while res_str != "" {
            for (id, each) in lookup_table.iter().enumerate() {
                (match_str, res_str) = Self::match_reg(res_str, each);

                // 如果匹配成功，则执行对应的handler
                if match_str != "" {
                    // 执行handler_func
                    handler_funcs.get(id).unwrap()(match_str);
                    break;
                }
            }

            // 未知错误
            if match_str == "" {
                println!("unknown error:{}", &res_str[..1]);
                res_str = &res_str[1..];
            }
        }
    }

    /// match_reg
    /// for match a sub string that match a reg
    /// return (matched_str, rest_str)
    fn match_reg<'a>(s: &'a str, lookup: &LookupTable) -> (&'a str, &'a str) {
        let mut state: usize = 0;
        let mut last_match_index = 0;
        let mut matched = false;

        for (index, each) in s.as_bytes().iter().enumerate() {
            if let Some(next_state) = lookup.states[state].get(each) {
                state = *next_state;

                // 如果可接受，则更新最后一个可接受状态
                if lookup.is_acceptable(state) {
                    last_match_index = index;
                    matched = true;
                }
            } else {
                break;
            }
        }

        if !matched {
            return ("", s);
        }
        (&s[..last_match_index + 1], &s[last_match_index + 1..])
    }
}
